/*
 * Wazuh Module for routing messages.
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "wm_vulnerability_scanner.h"
#include "external/cJSON/cJSON.h"
#include "sym_load.h"
#include "vulnerability_scanner.h"

static void wm_vulnerability_scanner_destroy();
cJSON* wm_vulnerability_scanner_dump();
static void wm_vulnerability_scanner_stop();
static void* wm_vulnerability_scanner_main();

void* vulnerability_scanner_module = NULL;
vulnerability_scanner_start_func vulnerability_scanner_start_ptr = NULL;
vulnerability_scanner_stop_func vulnerability_scanner_stop_ptr = NULL;

const wm_context WM_VULNERABILITY_SCANNER_CONTEXT = {
    .name = "vulnerability_scanner",
    .start = (wm_routine)wm_vulnerability_scanner_main,
    .destroy = (void (*)(void*))wm_vulnerability_scanner_destroy,
    .dump = (cJSON * (*)(const void*)) wm_vulnerability_scanner_dump,
    .sync = NULL,
    .stop = (void (*)(void*))wm_vulnerability_scanner_stop,
    .query = NULL,
};

void* wm_vulnerability_scanner_main()
{
    mtinfo(WM_VULNERABILITY_SCANNER_LOGTAG, "Starting vulnerability_scanner module.");
    if (vulnerability_scanner_module = so_get_module_handle("vulnerability_scanner"), vulnerability_scanner_module)
    {
        vulnerability_scanner_start_ptr =
            so_get_function_sym(vulnerability_scanner_module, "vulnerability_scanner_start");
        vulnerability_scanner_stop_ptr =
            so_get_function_sym(vulnerability_scanner_module, "vulnerability_scanner_stop");

        if (vulnerability_scanner_start_ptr)
        {
            vulnerability_scanner_start_ptr(NULL);
        }
        else
        {
            mtwarn(WM_VULNERABILITY_SCANNER_LOGTAG, "Unable to start vulnerability_scanner module.");
            return NULL;
        }
    }
    else
    {
        mtwarn(WM_VULNERABILITY_SCANNER_LOGTAG, "Unable to load vulnerability_scanner module.");
        return NULL;
    }

    return NULL;
}

void wm_vulnerability_scanner_destroy() {}

void wm_vulnerability_scanner_stop()
{
    mtinfo(WM_VULNERABILITY_SCANNER_LOGTAG, "Stopping vulnerability_scanner module.");
    if (vulnerability_scanner_stop_ptr)
    {
        vulnerability_scanner_stop_ptr();
    }
    else
    {
        mtwarn(WM_VULNERABILITY_SCANNER_LOGTAG, "Unable to stop vulnerability_scanner module.");
    }
}

wmodule* wm_vulnerability_scanner_read()
{
    wmodule* module;

    os_calloc(1, sizeof(wmodule), module);
    module->context = &WM_VULNERABILITY_SCANNER_CONTEXT;
    module->tag = strdup(module->context->name);
    mtinfo(WM_VULNERABILITY_SCANNER_LOGTAG, "Loaded vulnerability_scanner module.");
    return module;
}

cJSON* wm_vulnerability_scanner_dump()
{
    cJSON* root = cJSON_CreateObject();
    cJSON* wm_wd = cJSON_CreateObject();
    cJSON_AddStringToObject(wm_wd, "enabled", "yes");
    cJSON_AddItemToObject(root, "wazuh_control", wm_wd);
    return root;
}

